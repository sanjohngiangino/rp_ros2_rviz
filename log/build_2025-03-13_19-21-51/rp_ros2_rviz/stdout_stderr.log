[ 16%] Built target control_robot
[ 25%] [32mBuilding CXX object CMakeFiles/world_node.dir/src/grid_map.cpp.o[0m
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:[m[K In member function â€˜[01m[Kvirtual void GridMap::[01;32m[Kdraw[m[K(Canvas&) const[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:80:9:[m[K [01;35m[Kwarning: [m[Kvariable â€˜[01m[Kt[m[Kâ€™ set but not used [[01;35m[K]8;;https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wunused-but-set-variable-Wunused-but-set-variable]8;;[m[K]
   80 |   Vec2f [01;35m[Kt[m[K=_piw.t*(1./dest.resolution);
      |         [01;35m[K^[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:295[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid.h:4[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:3[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:1[m[K:
/usr/include/eigen3/Eigen/src/Core/Matrix.h: In instantiation of â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::[01;32m[KMatrix[m[K(const T&) [35m[K[with T = cv::Vec<int, 2>; _Scalar = int; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1][m[K[m[Kâ€™:
[01m[K/usr/include/c++/13/bits/new_allocator.h:191:4:[m[K   required from â€˜[01m[Kvoid std::__new_allocator<_Tp>::[01;32m[Kconstruct[m[K(_Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/alloc_traits.h:538:17:[m[K   required from â€˜[01m[Kstatic void std::allocator_traits<std::allocator<_CharT> >::[01;32m[Kconstruct[m[K(allocator_type&, _Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; allocator_type = std::allocator<Eigen::Matrix<int, 2, 1> >][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/vector.tcc:117:30:[m[K   required from â€˜[01m[Kstd::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::[01;32m[Kemplace_back[m[K(_Args&& ...) [35m[K[with _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; _Alloc = std::allocator<Eigen::Matrix<int, 2, 1> >; reference = Eigen::Matrix<int, 2, 1>&][m[K[m[Kâ€™
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:108:37:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:332:31:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KEigen::Matrix<int, 2, 1>::_init1<cv::Vec<int, 2> >(const cv::Vec<int, 2>&)[m[Kâ€™
  332 |       [01;31m[KBase::template _init1<T>(x)[m[K;
      |       [01;31m[K~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:294[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:839:30:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::[01;32m[K_init1[m[K(Eigen::Index, typename Eigen::internal::enable_if<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T>::type*) [35m[K[with T = cv::Vec<int, 2>; Derived = Eigen::Matrix<int, 2, 1>; Eigen::Index = long int; typename Eigen::internal::enable_if<(((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1) || (! std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value)) && ((! Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value) || (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == Eigen::Dynamic))), T>::type = cv::Vec<int, 2>; typename Eigen::internal::dense_xpr_base<Derived>::type = Eigen::MatrixBase<Eigen::Matrix<int, 2, 1> >; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr; typename Eigen::internal::traits<T>::Scalar = int; typename Eigen::internal::traits<T>::XprKind = Eigen::MatrixXpr][m[K[m[Kâ€™
  839 |     EIGEN_STRONG_INLINE void [01;36m[K_init1[m[K(Index size, typename internal::enable_if<    (Base::SizeAtCompileTime!=1 || !internal::is_convertible<T, Scalar>::value)
      |                              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:839:43:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst cv::Vec<int, 2>[m[Kâ€™ to â€˜[01m[KEigen::Index[m[Kâ€™ {aka â€˜[01m[Klong int[m[Kâ€™}
  839 |     EIGEN_STRONG_INLINE void _init1([01;36m[KIndex size[m[K, typename internal::enable_if<    (Base::SizeAtCompileTime!=1 || !internal::is_convertible<T, Scalar>::value)
      |                                     [01;36m[K~~~~~~^~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:853:30:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T> void Eigen::PlainObjectBase<Derived>::[01;32m[K_init1[m[K(const Scalar&, typename Eigen::internal::enable_if<((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T>::type*) [35m[K[with Derived = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
  853 |     EIGEN_STRONG_INLINE void [01;36m[K_init1[m[K(const Scalar& val0, typename internal::enable_if<Base::SizeAtCompileTime==1 && internal::is_convertible<T, Scalar>::value,T>::type* = 0)
      |                              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:853:30:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h: In substitution of â€˜[01m[Ktemplate<class T> void Eigen::PlainObjectBase<Eigen::Matrix<int, 2, 1> >::[01;32m[K_init1[m[K(const Scalar&, typename Eigen::internal::enable_if<((Eigen::MatrixBase<Eigen::Matrix<int, 2, 1> >::SizeAtCompileTime == 1) && std::is_convertible<_Iter, int>::value), T>::type*) [35m[K[with T = cv::Vec<int, 2>][m[K[m[Kâ€™:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:332:31:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::[01;32m[KMatrix[m[K(const T&) [35m[K[with T = cv::Vec<int, 2>; _Scalar = int; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/new_allocator.h:191:4:[m[K   required from â€˜[01m[Kvoid std::__new_allocator<_Tp>::[01;32m[Kconstruct[m[K(_Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/alloc_traits.h:538:17:[m[K   required from â€˜[01m[Kstatic void std::allocator_traits<std::allocator<_CharT> >::[01;32m[Kconstruct[m[K(allocator_type&, _Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; allocator_type = std::allocator<Eigen::Matrix<int, 2, 1> >][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/vector.tcc:117:30:[m[K   required from â€˜[01m[Kstd::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::[01;32m[Kemplace_back[m[K(_Args&& ...) [35m[K[with _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; _Alloc = std::allocator<Eigen::Matrix<int, 2, 1> >; reference = Eigen::Matrix<int, 2, 1>&][m[K[m[Kâ€™
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:108:37:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:853:30:[m[K [01;31m[Kerror: [m[Kinvalid use of incomplete type â€˜[01m[Kstruct Eigen::internal::enable_if<false, cv::Vec<int, 2> >[m[Kâ€™
In file included from [01m[K/usr/include/eigen3/Eigen/Core:162[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Meta.h:273:50:[m[K [01;36m[Knote: [m[Kdeclaration of â€˜[01m[Kstruct Eigen::internal::enable_if<false, cv::Vec<int, 2> >[m[Kâ€™
  273 | template<bool Condition, typename T=void> struct [01;36m[Kenable_if[m[K;
      |                                                  [01;36m[K^~~~~~~~~[m[K
/usr/include/eigen3/Eigen/src/Core/Matrix.h: In instantiation of â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::[01;32m[KMatrix[m[K(const T&) [35m[K[with T = cv::Vec<int, 2>; _Scalar = int; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1][m[K[m[Kâ€™:
[01m[K/usr/include/c++/13/bits/new_allocator.h:191:4:[m[K   required from â€˜[01m[Kvoid std::__new_allocator<_Tp>::[01;32m[Kconstruct[m[K(_Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/alloc_traits.h:538:17:[m[K   required from â€˜[01m[Kstatic void std::allocator_traits<std::allocator<_CharT> >::[01;32m[Kconstruct[m[K(allocator_type&, _Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; allocator_type = std::allocator<Eigen::Matrix<int, 2, 1> >][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/vector.tcc:117:30:[m[K   required from â€˜[01m[Kstd::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::[01;32m[Kemplace_back[m[K(_Args&& ...) [35m[K[with _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; _Alloc = std::allocator<Eigen::Matrix<int, 2, 1> >; reference = Eigen::Matrix<int, 2, 1>&][m[K[m[Kâ€™
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:108:37:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:862:30:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T> void Eigen::PlainObjectBase<Derived>::[01;32m[K_init1[m[K(const Eigen::Index&, typename Eigen::internal::enable_if<((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime == 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value), T*>::type*) [35m[K[with Derived = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
  862 |     EIGEN_STRONG_INLINE void [01;36m[K_init1[m[K(const Index& val0,
      |                              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:862:30:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h: In substitution of â€˜[01m[Ktemplate<class T> void Eigen::PlainObjectBase<Eigen::Matrix<int, 2, 1> >::[01;32m[K_init1[m[K(const Eigen::Index&, typename Eigen::internal::enable_if<((((! Eigen::internal::is_same<long int, int>::value) && Eigen::internal::is_same<long int, T>::value) && (Eigen::MatrixBase<Eigen::Matrix<int, 2, 1> >::SizeAtCompileTime == 1)) && std::is_convertible<_Iter, int>::value), T*>::type*) [35m[K[with T = cv::Vec<int, 2>][m[K[m[Kâ€™:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:332:31:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::[01;32m[KMatrix[m[K(const T&) [35m[K[with T = cv::Vec<int, 2>; _Scalar = int; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/new_allocator.h:191:4:[m[K   required from â€˜[01m[Kvoid std::__new_allocator<_Tp>::[01;32m[Kconstruct[m[K(_Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/alloc_traits.h:538:17:[m[K   required from â€˜[01m[Kstatic void std::allocator_traits<std::allocator<_CharT> >::[01;32m[Kconstruct[m[K(allocator_type&, _Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; allocator_type = std::allocator<Eigen::Matrix<int, 2, 1> >][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/vector.tcc:117:30:[m[K   required from â€˜[01m[Kstd::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::[01;32m[Kemplace_back[m[K(_Args&& ...) [35m[K[with _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; _Alloc = std::allocator<Eigen::Matrix<int, 2, 1> >; reference = Eigen::Matrix<int, 2, 1>&][m[K[m[Kâ€™
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:108:37:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:862:30:[m[K [01;31m[Kerror: [m[Kinvalid use of incomplete type â€˜[01m[Kstruct Eigen::internal::enable_if<false, cv::Vec<int, 2>*>[m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Meta.h:273:50:[m[K [01;36m[Knote: [m[Kdeclaration of â€˜[01m[Kstruct Eigen::internal::enable_if<false, cv::Vec<int, 2>*>[m[Kâ€™
  273 | template<bool Condition, typename T=void> struct [01;36m[Kenable_if[m[K;
      |                                                  [01;36m[K^~~~~~~~~[m[K
/usr/include/eigen3/Eigen/src/Core/Matrix.h: In instantiation of â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::[01;32m[KMatrix[m[K(const T&) [35m[K[with T = cv::Vec<int, 2>; _Scalar = int; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1][m[K[m[Kâ€™:
[01m[K/usr/include/c++/13/bits/new_allocator.h:191:4:[m[K   required from â€˜[01m[Kvoid std::__new_allocator<_Tp>::[01;32m[Kconstruct[m[K(_Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/alloc_traits.h:538:17:[m[K   required from â€˜[01m[Kstatic void std::allocator_traits<std::allocator<_CharT> >::[01;32m[Kconstruct[m[K(allocator_type&, _Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; allocator_type = std::allocator<Eigen::Matrix<int, 2, 1> >][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/vector.tcc:117:30:[m[K   required from â€˜[01m[Kstd::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::[01;32m[Kemplace_back[m[K(_Args&& ...) [35m[K[with _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; _Alloc = std::allocator<Eigen::Matrix<int, 2, 1> >; reference = Eigen::Matrix<int, 2, 1>&][m[K[m[Kâ€™
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:108:37:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:875:30:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::[01;32m[K_init1[m[K(const Scalar*) [35m[K[with T = cv::Vec<int, 2>; Derived = Eigen::Matrix<int, 2, 1>; Scalar = int][m[K[m[Kâ€™
  875 |     EIGEN_STRONG_INLINE void [01;36m[K_init1[m[K(const Scalar* data){
      |                              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:875:51:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst cv::Vec<int, 2>[m[Kâ€™ to â€˜[01m[Kconst Eigen::PlainObjectBase<Eigen::Matrix<int, 2, 1> >::Scalar*[m[Kâ€™ {aka â€˜[01m[Kconst int*[m[Kâ€™}
  875 |     EIGEN_STRONG_INLINE void _init1([01;36m[Kconst Scalar* data[m[K){
      |                                     [01;36m[K~~~~~~~~~~~~~~^~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:882:30:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::[01;32m[K_init1[m[K(const Eigen::DenseBase<ElseDerived>&) [35m[K[with OtherDerived = T; Derived = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
  882 |     EIGEN_STRONG_INLINE void [01;36m[K_init1[m[K(const DenseBase<OtherDerived>& other){
      |                              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:882:30:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:332:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst cv::Vec<int, 2>[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::DenseBase<Derived>[m[Kâ€™
  332 |       [01;36m[KBase::template _init1<T>(x)[m[K;
      |       [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:889:30:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::[01;32m[K_init1[m[K(const Derived&) [35m[K[with T = cv::Vec<int, 2>; Derived = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
  889 |     EIGEN_STRONG_INLINE void [01;36m[K_init1[m[K(const Derived& other){
      |                              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:889:52:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst cv::Vec<int, 2>[m[Kâ€™ to â€˜[01m[Kconst Eigen::Matrix<int, 2, 1>&[m[Kâ€™
  889 |     EIGEN_STRONG_INLINE void _init1([01;36m[Kconst Derived& other[m[K){
      |                                     [01;36m[K~~~~~~~~~~~~~~~^~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:896:30:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::[01;32m[K_init1[m[K(const Eigen::EigenBase<OtherDerived>&) [35m[K[with OtherDerived = T; Derived = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
  896 |     EIGEN_STRONG_INLINE void [01;36m[K_init1[m[K(const EigenBase<OtherDerived>& other){
      |                              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:896:30:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:332:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst cv::Vec<int, 2>[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::EigenBase<OtherDerived>[m[Kâ€™
  332 |       [01;36m[KBase::template _init1<T>(x)[m[K;
      |       [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:902:30:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class OtherDerived> void Eigen::PlainObjectBase<Derived>::[01;32m[K_init1[m[K(const Eigen::ReturnByValue<OtherDerived>&) [35m[K[with OtherDerived = T; Derived = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
  902 |     EIGEN_STRONG_INLINE void [01;36m[K_init1[m[K(const ReturnByValue<OtherDerived>& other)
      |                              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:902:30:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:332:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst cv::Vec<int, 2>[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::ReturnByValue<OtherDerived>[m[Kâ€™
  332 |       [01;36m[KBase::template _init1<T>(x)[m[K;
      |       [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:910:30:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class OtherDerived, int ColsAtCompileTime> void Eigen::PlainObjectBase<Derived>::[01;32m[K_init1[m[K(const Eigen::RotationBase<OtherDerived, ColsAtCompileTime>&) [35m[K[with OtherDerived = T; int ColsAtCompileTime = OtherDerived; Derived = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
  910 |     EIGEN_STRONG_INLINE void [01;36m[K_init1[m[K(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
      |                              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:910:30:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:332:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst cv::Vec<int, 2>[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::RotationBase<OtherDerived, ColsAtCompileTime>[m[Kâ€™
  332 |       [01;36m[KBase::template _init1<T>(x)[m[K;
      |       [01;36m[K~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:918:30:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T> void Eigen::PlainObjectBase<Derived>::[01;32m[K_init1[m[K(const Scalar&, typename Eigen::internal::enable_if<((((typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T>::type*) [35m[K[with Derived = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
  918 |     EIGEN_STRONG_INLINE void [01;36m[K_init1[m[K(const Scalar& val0,
      |                              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:918:30:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h: In substitution of â€˜[01m[Ktemplate<class T> void Eigen::PlainObjectBase<Eigen::Matrix<int, 2, 1> >::[01;32m[K_init1[m[K(const Scalar&, typename Eigen::internal::enable_if<((((Eigen::MatrixBase<Eigen::Matrix<int, 2, 1> >::SizeAtCompileTime != Eigen::Dynamic) && (Eigen::MatrixBase<Eigen::Matrix<int, 2, 1> >::SizeAtCompileTime != 1)) && std::is_convertible<_Iter, int>::value) && Eigen::internal::is_same<Eigen::MatrixXpr, Eigen::ArrayXpr>::value), T>::type*) [35m[K[with T = cv::Vec<int, 2>][m[K[m[Kâ€™:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:332:31:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::[01;32m[KMatrix[m[K(const T&) [35m[K[with T = cv::Vec<int, 2>; _Scalar = int; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/new_allocator.h:191:4:[m[K   required from â€˜[01m[Kvoid std::__new_allocator<_Tp>::[01;32m[Kconstruct[m[K(_Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/alloc_traits.h:538:17:[m[K   required from â€˜[01m[Kstatic void std::allocator_traits<std::allocator<_CharT> >::[01;32m[Kconstruct[m[K(allocator_type&, _Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; allocator_type = std::allocator<Eigen::Matrix<int, 2, 1> >][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/vector.tcc:117:30:[m[K   required from â€˜[01m[Kstd::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::[01;32m[Kemplace_back[m[K(_Args&& ...) [35m[K[with _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; _Alloc = std::allocator<Eigen::Matrix<int, 2, 1> >; reference = Eigen::Matrix<int, 2, 1>&][m[K[m[Kâ€™
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:108:37:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:918:30:[m[K [01;31m[Kerror: [m[Kinvalid use of incomplete type â€˜[01m[Kstruct Eigen::internal::enable_if<false, cv::Vec<int, 2> >[m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Meta.h:273:50:[m[K [01;36m[Knote: [m[Kdeclaration of â€˜[01m[Kstruct Eigen::internal::enable_if<false, cv::Vec<int, 2> >[m[Kâ€™
  273 | template<bool Condition, typename T=void> struct [01;36m[Kenable_if[m[K;
      |                                                  [01;36m[K^~~~~~~~~[m[K
/usr/include/eigen3/Eigen/src/Core/Matrix.h: In instantiation of â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::[01;32m[KMatrix[m[K(const T&) [35m[K[with T = cv::Vec<int, 2>; _Scalar = int; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1][m[K[m[Kâ€™:
[01m[K/usr/include/c++/13/bits/new_allocator.h:191:4:[m[K   required from â€˜[01m[Kvoid std::__new_allocator<_Tp>::[01;32m[Kconstruct[m[K(_Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/alloc_traits.h:538:17:[m[K   required from â€˜[01m[Kstatic void std::allocator_traits<std::allocator<_CharT> >::[01;32m[Kconstruct[m[K(allocator_type&, _Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; allocator_type = std::allocator<Eigen::Matrix<int, 2, 1> >][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/vector.tcc:117:30:[m[K   required from â€˜[01m[Kstd::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::[01;32m[Kemplace_back[m[K(_Args&& ...) [35m[K[with _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; _Alloc = std::allocator<Eigen::Matrix<int, 2, 1> >; reference = Eigen::Matrix<int, 2, 1>&][m[K[m[Kâ€™
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:108:37:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:930:30:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T> void Eigen::PlainObjectBase<Derived>::[01;32m[K_init1[m[K(const Eigen::Index&, typename Eigen::internal::enable_if<((((((! Eigen::internal::is_same<long int, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<long int, T>::value) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != Eigen::Dynamic)) && (typename Eigen::internal::dense_xpr_base<Derived>::type::SizeAtCompileTime != 1)) && std::is_convertible<T, typename Eigen::internal::traits<T>::Scalar>::value) && Eigen::internal::is_same<typename Eigen::internal::traits<T>::XprKind, Eigen::ArrayXpr>::value), T*>::type*) [35m[K[with Derived = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
  930 |     EIGEN_STRONG_INLINE void [01;36m[K_init1[m[K(const Index& val0,
      |                              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:930:30:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h: In substitution of â€˜[01m[Ktemplate<class T> void Eigen::PlainObjectBase<Eigen::Matrix<int, 2, 1> >::[01;32m[K_init1[m[K(const Eigen::Index&, typename Eigen::internal::enable_if<((((((! Eigen::internal::is_same<long int, int>::value) && Eigen::internal::is_same<long int, T>::value) && (Eigen::MatrixBase<Eigen::Matrix<int, 2, 1> >::SizeAtCompileTime != Eigen::Dynamic)) && (Eigen::MatrixBase<Eigen::Matrix<int, 2, 1> >::SizeAtCompileTime != 1)) && std::is_convertible<_Iter, int>::value) && Eigen::internal::is_same<Eigen::MatrixXpr, Eigen::ArrayXpr>::value), T*>::type*) [35m[K[with T = cv::Vec<int, 2>][m[K[m[Kâ€™:
[01m[K/usr/include/eigen3/Eigen/src/Core/Matrix.h:332:31:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::[01;32m[KMatrix[m[K(const T&) [35m[K[with T = cv::Vec<int, 2>; _Scalar = int; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/new_allocator.h:191:4:[m[K   required from â€˜[01m[Kvoid std::__new_allocator<_Tp>::[01;32m[Kconstruct[m[K(_Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/alloc_traits.h:538:17:[m[K   required from â€˜[01m[Kstatic void std::allocator_traits<std::allocator<_CharT> >::[01;32m[Kconstruct[m[K(allocator_type&, _Up*, _Args&& ...) [35m[K[with _Up = Eigen::Matrix<int, 2, 1>; _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; allocator_type = std::allocator<Eigen::Matrix<int, 2, 1> >][m[K[m[Kâ€™
[01m[K/usr/include/c++/13/bits/vector.tcc:117:30:[m[K   required from â€˜[01m[Kstd::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::[01;32m[Kemplace_back[m[K(_Args&& ...) [35m[K[with _Args = {cv::Vec<int, 2>}; _Tp = Eigen::Matrix<int, 2, 1>; _Alloc = std::allocator<Eigen::Matrix<int, 2, 1> >; reference = Eigen::Matrix<int, 2, 1>&][m[K[m[Kâ€™
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:108:37:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/PlainObjectBase.h:930:30:[m[K [01;31m[Kerror: [m[Kinvalid use of incomplete type â€˜[01m[Kstruct Eigen::internal::enable_if<false, cv::Vec<int, 2>*>[m[Kâ€™
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Meta.h:273:50:[m[K [01;36m[Knote: [m[Kdeclaration of â€˜[01m[Kstruct Eigen::internal::enable_if<false, cv::Vec<int, 2>*>[m[Kâ€™
  273 | template<bool Condition, typename T=void> struct [01;36m[Kenable_if[m[K;
      |                                                  [01;36m[K^~~~~~~~~[m[K
gmake[2]: *** [CMakeFiles/world_node.dir/build.make:104: CMakeFiles/world_node.dir/src/grid_map.cpp.o] Error 1
gmake[1]: *** [CMakeFiles/Makefile2:165: CMakeFiles/world_node.dir/all] Error 2
gmake: *** [Makefile:146: all] Error 2
