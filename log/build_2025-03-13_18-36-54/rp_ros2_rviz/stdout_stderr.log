[  8%] [32mBuilding CXX object CMakeFiles/world_node.dir/src/world_node.cpp.o[0m
[ 16%] [32mBuilding CXX object CMakeFiles/world_node.dir/src/lidar.cpp.o[0m
[ 33%] Built target control_robot
[ 41%] [32mBuilding CXX object CMakeFiles/world_node.dir/src/grid_map.cpp.o[0m
In file included from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/lidar.h:3[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/src/lidar.cpp:1[m[K:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:[m[K In member function â€˜[01m[KEigen::Vector2f GridMap::[01;32m[Kg2w[m[K(Eigen::Vector2f) const[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:19:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator-[m[Kâ€™ (operand types are â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} and â€˜[01m[Kconst Vec2f[m[Kâ€™)
   36 |     return _piw*([32m[Kg[m[K[01;31m[K-[m[K[34m[Kgrid_origin[m[K)*resolution;
      |                  [32m[K~[m[K[01;31m[K^[m[K[34m[K~~~~~~~~~~~[m[K
      |                  [32m[K|[m[K [34m[K|[m[K
      |                  [32m[K|[m[K [34m[Kconst Vec2f[m[K
      |                  [32m[Kconst Eigen::Vector2f {aka const Eigen::Matrix<float, 2, 1>}[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:19[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:7[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:19:28:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class OtherDerived> const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<typename Eigen::internal::traits<T>::Scalar, typename Eigen::internal::traits<OtherDerived>::Scalar>, const Derived, const OtherDerived> Eigen::MatrixBase<Derived>::[01;32m[Koperator-[m[K(const Eigen::MatrixBase<OtherDerived>&) const [35m[K[with Derived = Eigen::Matrix<float, 2, 1>][m[K[m[Kâ€™
   19 | EIGEN_MAKE_CWISE_BINARY_OP([01;36m[Koperator[m[K-,difference)
      |                            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1348:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_CWISE_BINARY_OP[m[Kâ€™
 1348 |   ([01;36m[KMETHOD[m[K)(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:19:28:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
   19 | EIGEN_MAKE_CWISE_BINARY_OP([01;36m[Koperator[m[K-,difference)
      |                            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1348:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_CWISE_BINARY_OP[m[Kâ€™
 1348 |   ([01;36m[KMETHOD[m[K)(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const \
      |    [01;36m[K^~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Vec2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/src/Core/DenseBase.h:658[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/Core:272[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h:45:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kconst Eigen::DenseBase<Derived>::NegativeReturnType Eigen::DenseBase<Derived>::[01;32m[Koperator-[m[K() const [35m[K[with Derived = Eigen::Matrix<float, 2, 1>; NegativeReturnType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<float>, const Eigen::Matrix<float, 2, 1> >][m[K[m[Kâ€™
   45 | [01;36m[Koperator[m[K-() const { return NegativeReturnType(derived()); }
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h:45:1:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 1 provided
In file included from [01m[K/usr/include/c++/13/string:48[m[K,
                 from [01m[K/usr/include/c++/13/bits/locale_classes.h:40[m[K,
                 from [01m[K/usr/include/c++/13/bits/ios_base.h:41[m[K,
                 from [01m[K/usr/include/c++/13/ios:44[m[K,
                 from [01m[K/usr/include/c++/13/ostream:40[m[K,
                 from [01m[K/usr/include/c++/13/iostream:41[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/world.h:2[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/lidar.h:2[m[K:
[01m[K/usr/include/c++/13/bits/stl_iterator.h:625:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _IteratorL, class _IteratorR> constexpr decltype ((__y.base() - __x.base())) std::[01;32m[Koperator-[m[K(const reverse_iterator<_Iterator>&, const reverse_iterator<_IteratorR>&)[m[Kâ€™
  625 |     [01;36m[Koperator[m[K-(const reverse_iterator<_IteratorL>& __x,
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/bits/stl_iterator.h:625:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::reverse_iterator<_Iterator>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/bits/stl_iterator.h:1800:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _IteratorL, class _IteratorR> constexpr decltype ((__x.base() - __y.base())) std::[01;32m[Koperator-[m[K(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)[m[Kâ€™
 1800 |     [01;36m[Koperator[m[K-(const move_iterator<_IteratorL>& __x,
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/bits/stl_iterator.h:1800:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::move_iterator<_IteratorL>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/opencv4/opencv2/core/cvstd.inl.hpp:47[m[K,
                 from [01m[K/usr/include/opencv4/opencv2/core.hpp:3349[m[K,
                 from [01m[K/usr/include/opencv4/opencv2/opencv.hpp:52[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/canvas.h:2[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/world.h:6[m[K:
[01m[K/usr/include/c++/13/complex:365:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const complex<_Tp>&, const complex<_Tp>&)[m[Kâ€™
  365 |     [01;36m[Koperator[m[K-(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:365:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:374:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const complex<_Tp>&, const _Tp&)[m[Kâ€™
  374 |     [01;36m[Koperator[m[K-(const complex<_Tp>& __x, const _Tp& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:374:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:383:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const _Tp&, const complex<_Tp>&)[m[Kâ€™
  383 |     [01;36m[Koperator[m[K-(const _Tp& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:383:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Vec2f[m[Kâ€™ is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:460:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const complex<_Tp>&)[m[Kâ€™
  460 |     [01;36m[Koperator[m[K-(const complex<_Tp>& __x)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:460:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:[m[K In member function â€˜[01m[KEigen::Vector2f GridMap::[01;32m[Kw2g[m[K(Eigen::Vector2f) const[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:18:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator*[m[Kâ€™ (operand types are â€˜[01m[Kconst Isometry2f[m[Kâ€™ and â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™})
   41 |     return ([32m[K_ipiw[m[K[01;31m[K*[m[K[34m[Kw[m[K)*inv_resolution+grid_origin;
      |             [32m[K~~~~~[m[K[01;31m[K^[m[K[34m[K~[m[K
      |             [32m[K|[m[K     [34m[K|[m[K
      |             [32m[K|[m[K     [34m[Kconst Eigen::Vector2f {aka const Eigen::Matrix<float, 2, 1>}[m[K
      |             [32m[Kconst Isometry2f[m[K
In file included from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/world.h:5[m[K:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:207:21:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KIsometry2f Isometry2f::[01;32m[Koperator*[m[K(const Isometry2f&) const[m[Kâ€™
  207 |   inline Isometry2f [01;36m[Koperator[m[K*(const Isometry2f& src) const {
      |                     [01;36m[K^~~~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:207:49:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} to â€˜[01m[Kconst Isometry2f&[m[Kâ€™
  207 |   inline Isometry2f operator*([01;36m[Kconst Isometry2f& src[m[K) const {
      |                               [01;36m[K~~~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:221:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KVec2f Isometry2f::[01;32m[Koperator*[m[K(const Vec2f&) const[m[Kâ€™
  221 |   inline Vec2f [01;36m[Koperator[m[K*(const Vec2f& src) const {
      |                [01;36m[K^~~~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:221:39:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} to â€˜[01m[Kconst Vec2f&[m[Kâ€™
  221 |   inline Vec2f operator*([01;36m[Kconst Vec2f& src[m[K) const {
      |                          [01;36m[K~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/c++/13/complex:395:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator*[m[K(const complex<_Tp>&, const complex<_Tp>&)[m[Kâ€™
  395 |     [01;36m[Koperator[m[K*(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:395:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/c++/13/complex:404:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator*[m[K(const complex<_Tp>&, const _Tp&)[m[Kâ€™
  404 |     [01;36m[Koperator[m[K*(const complex<_Tp>& __x, const _Tp& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:404:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/c++/13/complex:413:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator*[m[K(const _Tp&, const complex<_Tp>&)[m[Kâ€™
  413 |     [01;36m[Koperator[m[K*(const _Tp& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:413:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:29:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T> const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type, float>, const typename Eigen::internal::plain_constant_type<Eigen::Matrix<float, 2, 1>, typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type>::type, const Eigen::Matrix<float, 2, 1> > Eigen::[01;32m[Koperator*[m[K(const T&, const MatrixBase<Matrix<float, 2, 1> >::StorageBaseType&)[m[Kâ€™
   50 | EIGEN_MAKE_SCALAR_BINARY_OP([01;36m[Koperator[m[K*,product)
      |                             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1383:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP_ONTHELEFT[m[Kâ€™
 1383 |   ([01;36m[KMETHOD[m[K)(const T& scalar, const StorageBaseType& matrix) { \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[Kin expansion of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[Kâ€™
   50 | [01;36m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[K(operator*,product)
      | [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:29:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
   50 | EIGEN_MAKE_SCALAR_BINARY_OP([01;36m[Koperator[m[K*,product)
      |                             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1383:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP_ONTHELEFT[m[Kâ€™
 1383 |   ([01;36m[KMETHOD[m[K)(const T& scalar, const StorageBaseType& matrix) { \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[Kin expansion of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[Kâ€™
   50 | [01;36m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[K(operator*,product)
      | [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h: In substitution of â€˜[01m[Ktemplate<class T> const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type, float>, const typename Eigen::internal::plain_constant_type<Eigen::Matrix<float, 2, 1>, typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type>::type, const Eigen::Matrix<float, 2, 1> > Eigen::[01;32m[Koperator*[m[K(const T&, const MatrixBase<Matrix<float, 2, 1> >::StorageBaseType&) [35m[K[with T = Isometry2f][m[K[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:29:[m[K [01;31m[Kerror: [m[Kno type named â€˜[01m[Ktype[m[Kâ€™ in â€˜[01m[Kstruct Eigen::internal::promote_scalar_arg<float, Isometry2f, false>[m[Kâ€™
   50 | EIGEN_MAKE_SCALAR_BINARY_OP([01;31m[Koperator[m[K*,product)
      |                             [01;31m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1383:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP_ONTHELEFT[m[Kâ€™
 1383 |   ([01;36m[KMETHOD[m[K)(const T& scalar, const StorageBaseType& matrix) { \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[Kin expansion of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[Kâ€™
   50 | [01;36m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[K(operator*,product)
      | [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:326[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:515:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class MatrixDerived, class PermutationDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const MatrixBase<Derived>&, const PermutationBase<PermutationDerived>&)[m[Kâ€™
  515 | [01;36m[Koperator[m[K*(const MatrixBase<MatrixDerived> &matrix,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:515:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:527:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class PermutationDerived, class MatrixDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const PermutationBase<PermutationDerived>&, const MatrixBase<U>&)[m[Kâ€™
  527 | [01;36m[Koperator[m[K*(const PermutationBase<PermutationDerived> &permutation,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:527:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::PermutationBase<PermutationDerived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:327[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:313:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class MatrixDerived, class TranspositionsDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const MatrixBase<Derived>&, const TranspositionsBase<TranspositionsDerived>&)[m[Kâ€™
  313 | [01;36m[Koperator[m[K*(const MatrixBase<MatrixDerived> &matrix,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:313:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:325:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class TranspositionsDerived, class MatrixDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const TranspositionsBase<TranspositionsDerived>&, const MatrixBase<U>&)[m[Kâ€™
  325 | [01;36m[Koperator[m[K*(const TranspositionsBase<TranspositionsDerived> &transpositions,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:325:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::TranspositionsBase<TranspositionsDerived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
In file included from [01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:1[m[K:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:[m[K In member function â€˜[01m[KEigen::Vector2f GridMap::[01;32m[Kg2w[m[K(Eigen::Vector2f) const[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:19:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator-[m[Kâ€™ (operand types are â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} and â€˜[01m[Kconst Vec2f[m[Kâ€™)
   36 |     return _piw*([32m[Kg[m[K[01;31m[K-[m[K[34m[Kgrid_origin[m[K)*resolution;
      |                  [32m[K~[m[K[01;31m[K^[m[K[34m[K~~~~~~~~~~~[m[K
      |                  [32m[K|[m[K [34m[K|[m[K
      |                  [32m[K|[m[K [34m[Kconst Vec2f[m[K
      |                  [32m[Kconst Eigen::Vector2f {aka const Eigen::Matrix<float, 2, 1>}[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:19[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:7[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:19:28:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class OtherDerived> const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<typename Eigen::internal::traits<T>::Scalar, typename Eigen::internal::traits<OtherDerived>::Scalar>, const Derived, const OtherDerived> Eigen::MatrixBase<Derived>::[01;32m[Koperator-[m[K(const Eigen::MatrixBase<OtherDerived>&) const [35m[K[with Derived = Eigen::Matrix<float, 2, 1>][m[K[m[Kâ€™
   19 | EIGEN_MAKE_CWISE_BINARY_OP([01;36m[Koperator[m[K-,difference)
      |                            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1348:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_CWISE_BINARY_OP[m[Kâ€™
 1348 |   ([01;36m[KMETHOD[m[K)(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:19:28:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
   19 | EIGEN_MAKE_CWISE_BINARY_OP([01;36m[Koperator[m[K-,difference)
      |                            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1348:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_CWISE_BINARY_OP[m[Kâ€™
 1348 |   ([01;36m[KMETHOD[m[K)(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const \
      |    [01;36m[K^~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Vec2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/src/Core/DenseBase.h:658[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/Core:272[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h:45:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kconst Eigen::DenseBase<Derived>::NegativeReturnType Eigen::DenseBase<Derived>::[01;32m[Koperator-[m[K() const [35m[K[with Derived = Eigen::Matrix<float, 2, 1>; NegativeReturnType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<float>, const Eigen::Matrix<float, 2, 1> >][m[K[m[Kâ€™
   45 | [01;36m[Koperator[m[K-() const { return NegativeReturnType(derived()); }
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h:45:1:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 1 provided
In file included from [01m[K/usr/include/c++/13/string:48[m[K,
                 from [01m[K/usr/include/c++/13/bits/locale_classes.h:40[m[K,
                 from [01m[K/usr/include/c++/13/bits/ios_base.h:41[m[K,
                 from [01m[K/usr/include/c++/13/ios:44[m[K,
                 from [01m[K/usr/include/c++/13/ostream:40[m[K,
                 from [01m[K/usr/include/c++/13/iostream:41[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:2[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:2[m[K:
[01m[K/usr/include/c++/13/bits/stl_iterator.h:625:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _IteratorL, class _IteratorR> constexpr decltype ((__y.base() - __x.base())) std::[01;32m[Koperator-[m[K(const reverse_iterator<_Iterator>&, const reverse_iterator<_IteratorR>&)[m[Kâ€™
  625 |     [01;36m[Koperator[m[K-(const reverse_iterator<_IteratorL>& __x,
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/bits/stl_iterator.h:625:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::reverse_iterator<_Iterator>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/bits/stl_iterator.h:1800:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _IteratorL, class _IteratorR> constexpr decltype ((__x.base() - __y.base())) std::[01;32m[Koperator-[m[K(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)[m[Kâ€™
 1800 |     [01;36m[Koperator[m[K-(const move_iterator<_IteratorL>& __x,
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/bits/stl_iterator.h:1800:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::move_iterator<_IteratorL>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/opencv4/opencv2/core/cvstd.inl.hpp:47[m[K,
                 from [01m[K/usr/include/opencv4/opencv2/core.hpp:3349[m[K,
                 from [01m[K/usr/include/opencv4/opencv2/opencv.hpp:52[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/canvas.h:2[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/world.h:6[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:4[m[K:
[01m[K/usr/include/c++/13/complex:365:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const complex<_Tp>&, const complex<_Tp>&)[m[Kâ€™
  365 |     [01;36m[Koperator[m[K-(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:365:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:374:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const complex<_Tp>&, const _Tp&)[m[Kâ€™
  374 |     [01;36m[Koperator[m[K-(const complex<_Tp>& __x, const _Tp& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:374:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:383:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const _Tp&, const complex<_Tp>&)[m[Kâ€™
  383 |     [01;36m[Koperator[m[K-(const _Tp& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:383:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Vec2f[m[Kâ€™ is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:460:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const complex<_Tp>&)[m[Kâ€™
  460 |     [01;36m[Koperator[m[K-(const complex<_Tp>& __x)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:460:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/src/lidar.cpp:[m[K In member function â€˜[01m[Kvirtual void Lidar::[01;32m[KtimerTick[m[K(float)[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/src/lidar.cpp:45:36:[m[K [01;31m[Kerror: [m[Kcannot convert â€˜[01m[KVec2f[m[Kâ€™ to â€˜[01m[KEigen::Vector2f[m[Kâ€™ {aka â€˜[01m[KEigen::Matrix<float, 2, 1>[m[Kâ€™}
   45 |   Vec2f lidar_origin=gmap->w2g([01;31m[Kliw.t[m[K);
      |                                [01;31m[K~~~~^[m[K
      |                                    [01;31m[K|[m[K
      |                                    [01;31m[KVec2f[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:40:52:[m[K [01;36m[Knote: [m[K  initializing argument 1 of â€˜[01m[KEigen::Vector2f GridMap::[01;32m[Kw2g[m[K(Eigen::Vector2f) const[m[Kâ€™
   40 |   inline Eigen::Vector2f w2g([01;36m[Kconst Eigen::Vector2f w[m[K) const {
      |                              [01;36m[K~~~~~~~~~~~~~~~~~~~~~~^[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/src/lidar.cpp:31:29:[m[K [01;35m[Kwarning: [m[Kunused parameter â€˜[01m[Kdt[m[Kâ€™ [[01;35m[K]8;;https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wunused-parameter-Wunused-parameter]8;;[m[K]
   31 | void Lidar::timerTick([01;35m[Kfloat dt[m[K) {
      |                       [01;35m[K~~~~~~^~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:[m[K In member function â€˜[01m[KEigen::Vector2f GridMap::[01;32m[Kw2g[m[K(Eigen::Vector2f) const[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:18:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator*[m[Kâ€™ (operand types are â€˜[01m[Kconst Isometry2f[m[Kâ€™ and â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™})
   41 |     return ([32m[K_ipiw[m[K[01;31m[K*[m[K[34m[Kw[m[K)*inv_resolution+grid_origin;
      |             [32m[K~~~~~[m[K[01;31m[K^[m[K[34m[K~[m[K
      |             [32m[K|[m[K     [34m[K|[m[K
      |             [32m[K|[m[K     [34m[Kconst Eigen::Vector2f {aka const Eigen::Matrix<float, 2, 1>}[m[K
      |             [32m[Kconst Isometry2f[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:207:21:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KIsometry2f Isometry2f::[01;32m[Koperator*[m[K(const Isometry2f&) const[m[Kâ€™
  207 |   inline Isometry2f [01;36m[Koperator[m[K*(const Isometry2f& src) const {
      |                     [01;36m[K^~~~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:207:49:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} to â€˜[01m[Kconst Isometry2f&[m[Kâ€™
  207 |   inline Isometry2f operator*([01;36m[Kconst Isometry2f& src[m[K) const {
      |                               [01;36m[K~~~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:221:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KVec2f Isometry2f::[01;32m[Koperator*[m[K(const Vec2f&) const[m[Kâ€™
  221 |   inline Vec2f [01;36m[Koperator[m[K*(const Vec2f& src) const {
      |                [01;36m[K^~~~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:221:39:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} to â€˜[01m[Kconst Vec2f&[m[Kâ€™
  221 |   inline Vec2f operator*([01;36m[Kconst Vec2f& src[m[K) const {
      |                          [01;36m[K~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/c++/13/complex:395:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator*[m[K(const complex<_Tp>&, const complex<_Tp>&)[m[Kâ€™
  395 |     [01;36m[Koperator[m[K*(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:395:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/c++/13/complex:404:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator*[m[K(const complex<_Tp>&, const _Tp&)[m[Kâ€™
  404 |     [01;36m[Koperator[m[K*(const complex<_Tp>& __x, const _Tp& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:404:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/c++/13/complex:413:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator*[m[K(const _Tp&, const complex<_Tp>&)[m[Kâ€™
  413 |     [01;36m[Koperator[m[K*(const _Tp& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:413:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:29:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T> const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type, float>, const typename Eigen::internal::plain_constant_type<Eigen::Matrix<float, 2, 1>, typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type>::type, const Eigen::Matrix<float, 2, 1> > Eigen::[01;32m[Koperator*[m[K(const T&, const MatrixBase<Matrix<float, 2, 1> >::StorageBaseType&)[m[Kâ€™
   50 | EIGEN_MAKE_SCALAR_BINARY_OP([01;36m[Koperator[m[K*,product)
      |                             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1383:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP_ONTHELEFT[m[Kâ€™
 1383 |   ([01;36m[KMETHOD[m[K)(const T& scalar, const StorageBaseType& matrix) { \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[Kin expansion of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[Kâ€™
   50 | [01;36m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[K(operator*,product)
      | [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:29:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
   50 | EIGEN_MAKE_SCALAR_BINARY_OP([01;36m[Koperator[m[K*,product)
      |                             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1383:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP_ONTHELEFT[m[Kâ€™
 1383 |   ([01;36m[KMETHOD[m[K)(const T& scalar, const StorageBaseType& matrix) { \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[Kin expansion of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[Kâ€™
   50 | [01;36m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[K(operator*,product)
      | [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h: In substitution of â€˜[01m[Ktemplate<class T> const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type, float>, const typename Eigen::internal::plain_constant_type<Eigen::Matrix<float, 2, 1>, typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type>::type, const Eigen::Matrix<float, 2, 1> > Eigen::[01;32m[Koperator*[m[K(const T&, const MatrixBase<Matrix<float, 2, 1> >::StorageBaseType&) [35m[K[with T = Isometry2f][m[K[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:29:[m[K [01;31m[Kerror: [m[Kno type named â€˜[01m[Ktype[m[Kâ€™ in â€˜[01m[Kstruct Eigen::internal::promote_scalar_arg<float, Isometry2f, false>[m[Kâ€™
   50 | EIGEN_MAKE_SCALAR_BINARY_OP([01;31m[Koperator[m[K*,product)
      |                             [01;31m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1383:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP_ONTHELEFT[m[Kâ€™
 1383 |   ([01;36m[KMETHOD[m[K)(const T& scalar, const StorageBaseType& matrix) { \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[Kin expansion of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[Kâ€™
   50 | [01;36m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[K(operator*,product)
      | [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:326[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:515:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class MatrixDerived, class PermutationDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const MatrixBase<Derived>&, const PermutationBase<PermutationDerived>&)[m[Kâ€™
  515 | [01;36m[Koperator[m[K*(const MatrixBase<MatrixDerived> &matrix,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:515:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:527:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class PermutationDerived, class MatrixDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const PermutationBase<PermutationDerived>&, const MatrixBase<U>&)[m[Kâ€™
  527 | [01;36m[Koperator[m[K*(const PermutationBase<PermutationDerived> &permutation,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:527:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::PermutationBase<PermutationDerived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:327[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:313:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class MatrixDerived, class TranspositionsDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const MatrixBase<Derived>&, const TranspositionsBase<TranspositionsDerived>&)[m[Kâ€™
  313 | [01;36m[Koperator[m[K*(const MatrixBase<MatrixDerived> &matrix,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:313:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:325:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class TranspositionsDerived, class MatrixDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const TranspositionsBase<TranspositionsDerived>&, const MatrixBase<U>&)[m[Kâ€™
  325 | [01;36m[Koperator[m[K*(const TranspositionsBase<TranspositionsDerived> &transpositions,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:325:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::TranspositionsBase<TranspositionsDerived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:[m[K In member function â€˜[01m[Kvirtual bool GridMap::[01;32m[Kcollides[m[K(const WorldItem*) const[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/src/grid_map.cpp:29:36:[m[K [01;31m[Kerror: [m[Kcannot convert â€˜[01m[KVec2f[m[Kâ€™ to â€˜[01m[KEigen::Vector2f[m[Kâ€™ {aka â€˜[01m[KEigen::Matrix<float, 2, 1>[m[Kâ€™}
   29 |   Vec2f gp=w2g([01;31m[Kitem->poseInWorld().t[m[K);
      |                [01;31m[K~~~~~~~~~~~~~~~~~~~~^[m[K
      |                                    [01;31m[K|[m[K
      |                                    [01;31m[KVec2f[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:40:52:[m[K [01;36m[Knote: [m[K  initializing argument 1 of â€˜[01m[KEigen::Vector2f GridMap::[01;32m[Kw2g[m[K(Eigen::Vector2f) const[m[Kâ€™
   40 |   inline Eigen::Vector2f w2g([01;36m[Kconst Eigen::Vector2f w[m[K) const {
      |                              [01;36m[K~~~~~~~~~~~~~~~~~~~~~~^[m[K
gmake[2]: *** [CMakeFiles/world_node.dir/build.make:104: CMakeFiles/world_node.dir/src/grid_map.cpp.o] Error 1
gmake[2]: *** Waiting for unfinished jobs....
gmake[2]: *** [CMakeFiles/world_node.dir/build.make:160: CMakeFiles/world_node.dir/src/lidar.cpp.o] Error 1
In file included from [01m[K/home/john/Desktop/rp_ros2_rviz/src/world_node.cpp:5[m[K:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:[m[K In member function â€˜[01m[KEigen::Vector2f GridMap::[01;32m[Kg2w[m[K(Eigen::Vector2f) const[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:19:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator-[m[Kâ€™ (operand types are â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} and â€˜[01m[Kconst Vec2f[m[Kâ€™)
   36 |     return _piw*([32m[Kg[m[K[01;31m[K-[m[K[34m[Kgrid_origin[m[K)*resolution;
      |                  [32m[K~[m[K[01;31m[K^[m[K[34m[K~~~~~~~~~~~[m[K
      |                  [32m[K|[m[K [34m[K|[m[K
      |                  [32m[K|[m[K [34m[Kconst Vec2f[m[K
      |                  [32m[Kconst Eigen::Vector2f {aka const Eigen::Matrix<float, 2, 1>}[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:19[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:7[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:19:28:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class OtherDerived> const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<typename Eigen::internal::traits<T>::Scalar, typename Eigen::internal::traits<OtherDerived>::Scalar>, const Derived, const OtherDerived> Eigen::MatrixBase<Derived>::[01;32m[Koperator-[m[K(const Eigen::MatrixBase<OtherDerived>&) const [35m[K[with Derived = Eigen::Matrix<float, 2, 1>][m[K[m[Kâ€™
   19 | EIGEN_MAKE_CWISE_BINARY_OP([01;36m[Koperator[m[K-,difference)
      |                            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1348:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_CWISE_BINARY_OP[m[Kâ€™
 1348 |   ([01;36m[KMETHOD[m[K)(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:19:28:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
   19 | EIGEN_MAKE_CWISE_BINARY_OP([01;36m[Koperator[m[K-,difference)
      |                            [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1348:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_CWISE_BINARY_OP[m[Kâ€™
 1348 |   ([01;36m[KMETHOD[m[K)(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const \
      |    [01;36m[K^~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Vec2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/src/Core/DenseBase.h:658[m[K,
                 from [01m[K/usr/include/eigen3/Eigen/Core:272[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h:45:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kconst Eigen::DenseBase<Derived>::NegativeReturnType Eigen::DenseBase<Derived>::[01;32m[Koperator-[m[K() const [35m[K[with Derived = Eigen::Matrix<float, 2, 1>; NegativeReturnType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<float>, const Eigen::Matrix<float, 2, 1> >][m[K[m[Kâ€™
   45 | [01;36m[Koperator[m[K-() const { return NegativeReturnType(derived()); }
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h:45:1:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 1 provided
In file included from [01m[K/usr/include/c++/13/bits/stl_algobase.h:67[m[K,
                 from [01m[K/usr/include/c++/13/bits/stl_uninitialized.h:63[m[K,
                 from [01m[K/usr/include/c++/13/memory:69[m[K,
                 from [01m[K/opt/ros/jazzy/include/rclcpp/rclcpp/rclcpp.hpp:169[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/src/world_node.cpp:1[m[K:
[01m[K/usr/include/c++/13/bits/stl_iterator.h:625:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _IteratorL, class _IteratorR> constexpr decltype ((__y.base() - __x.base())) std::[01;32m[Koperator-[m[K(const reverse_iterator<_Iterator>&, const reverse_iterator<_IteratorR>&)[m[Kâ€™
  625 |     [01;36m[Koperator[m[K-(const reverse_iterator<_IteratorL>& __x,
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/bits/stl_iterator.h:625:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::reverse_iterator<_Iterator>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/bits/stl_iterator.h:1800:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _IteratorL, class _IteratorR> constexpr decltype ((__x.base() - __y.base())) std::[01;32m[Koperator-[m[K(const move_iterator<_IteratorL>&, const move_iterator<_IteratorR>&)[m[Kâ€™
 1800 |     [01;36m[Koperator[m[K-(const move_iterator<_IteratorL>& __x,
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/bits/stl_iterator.h:1800:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::move_iterator<_IteratorL>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/opencv4/opencv2/core/cvstd.inl.hpp:47[m[K,
                 from [01m[K/usr/include/opencv4/opencv2/core.hpp:3349[m[K,
                 from [01m[K/usr/include/opencv4/opencv2/opencv.hpp:52[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/canvas.h:2[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/world.h:6[m[K,
                 from [01m[K/home/john/Desktop/rp_ros2_rviz/src/world_node.cpp:3[m[K:
[01m[K/usr/include/c++/13/complex:365:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const complex<_Tp>&, const complex<_Tp>&)[m[Kâ€™
  365 |     [01;36m[Koperator[m[K-(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:365:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:374:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const complex<_Tp>&, const _Tp&)[m[Kâ€™
  374 |     [01;36m[Koperator[m[K-(const complex<_Tp>& __x, const _Tp& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:374:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:383:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const _Tp&, const complex<_Tp>&)[m[Kâ€™
  383 |     [01;36m[Koperator[m[K-(const _Tp& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:383:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Vec2f[m[Kâ€™ is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:460:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator-[m[K(const complex<_Tp>&)[m[Kâ€™
  460 |     [01;36m[Koperator[m[K-(const complex<_Tp>& __x)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:460:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:36:20:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   36 |     return _piw*(g-[01;36m[Kgrid_origin[m[K)*resolution;
      |                    [01;36m[K^~~~~~~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:[m[K In member function â€˜[01m[KEigen::Vector2f GridMap::[01;32m[Kw2g[m[K(Eigen::Vector2f) const[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:18:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator*[m[Kâ€™ (operand types are â€˜[01m[Kconst Isometry2f[m[Kâ€™ and â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™})
   41 |     return ([32m[K_ipiw[m[K[01;31m[K*[m[K[34m[Kw[m[K)*inv_resolution+grid_origin;
      |             [32m[K~~~~~[m[K[01;31m[K^[m[K[34m[K~[m[K
      |             [32m[K|[m[K     [34m[K|[m[K
      |             [32m[K|[m[K     [34m[Kconst Eigen::Vector2f {aka const Eigen::Matrix<float, 2, 1>}[m[K
      |             [32m[Kconst Isometry2f[m[K
In file included from [01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/world.h:5[m[K:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:207:21:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KIsometry2f Isometry2f::[01;32m[Koperator*[m[K(const Isometry2f&) const[m[Kâ€™
  207 |   inline Isometry2f [01;36m[Koperator[m[K*(const Isometry2f& src) const {
      |                     [01;36m[K^~~~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:207:49:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} to â€˜[01m[Kconst Isometry2f&[m[Kâ€™
  207 |   inline Isometry2f operator*([01;36m[Kconst Isometry2f& src[m[K) const {
      |                               [01;36m[K~~~~~~~~~~~~~~~~~~^~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:221:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KVec2f Isometry2f::[01;32m[Koperator*[m[K(const Vec2f&) const[m[Kâ€™
  221 |   inline Vec2f [01;36m[Koperator[m[K*(const Vec2f& src) const {
      |                [01;36m[K^~~~~~~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/linalg.h:221:39:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} to â€˜[01m[Kconst Vec2f&[m[Kâ€™
  221 |   inline Vec2f operator*([01;36m[Kconst Vec2f& src[m[K) const {
      |                          [01;36m[K~~~~~~~~~~~~~^~~[m[K
[01m[K/usr/include/c++/13/complex:395:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator*[m[K(const complex<_Tp>&, const complex<_Tp>&)[m[Kâ€™
  395 |     [01;36m[Koperator[m[K*(const complex<_Tp>& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:395:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/c++/13/complex:404:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator*[m[K(const complex<_Tp>&, const _Tp&)[m[Kâ€™
  404 |     [01;36m[Koperator[m[K*(const complex<_Tp>& __x, const _Tp& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:404:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/c++/13/complex:413:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp> std::complex<_Tp> std::[01;32m[Koperator*[m[K(const _Tp&, const complex<_Tp>&)[m[Kâ€™
  413 |     [01;36m[Koperator[m[K*(const _Tp& __x, const complex<_Tp>& __y)
      |     [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/c++/13/complex:413:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Eigen::Vector2f[m[Kâ€™ {aka â€˜[01m[Kconst Eigen::Matrix<float, 2, 1>[m[Kâ€™} is not derived from â€˜[01m[Kconst std::complex<_Tp>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:29:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T> const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type, float>, const typename Eigen::internal::plain_constant_type<Eigen::Matrix<float, 2, 1>, typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type>::type, const Eigen::Matrix<float, 2, 1> > Eigen::[01;32m[Koperator*[m[K(const T&, const MatrixBase<Matrix<float, 2, 1> >::StorageBaseType&)[m[Kâ€™
   50 | EIGEN_MAKE_SCALAR_BINARY_OP([01;36m[Koperator[m[K*,product)
      |                             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1383:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP_ONTHELEFT[m[Kâ€™
 1383 |   ([01;36m[KMETHOD[m[K)(const T& scalar, const StorageBaseType& matrix) { \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[Kin expansion of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[Kâ€™
   50 | [01;36m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[K(operator*,product)
      | [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:29:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
   50 | EIGEN_MAKE_SCALAR_BINARY_OP([01;36m[Koperator[m[K*,product)
      |                             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1383:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP_ONTHELEFT[m[Kâ€™
 1383 |   ([01;36m[KMETHOD[m[K)(const T& scalar, const StorageBaseType& matrix) { \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[Kin expansion of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[Kâ€™
   50 | [01;36m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[K(operator*,product)
      | [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h: In substitution of â€˜[01m[Ktemplate<class T> const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type, float>, const typename Eigen::internal::plain_constant_type<Eigen::Matrix<float, 2, 1>, typename Eigen::internal::promote_scalar_arg<float, T, Eigen::internal::has_ReturnType<Eigen::ScalarBinaryOpTraits<T, float, Eigen::internal::scalar_product_op<T, float> > >::value>::type>::type, const Eigen::Matrix<float, 2, 1> > Eigen::[01;32m[Koperator*[m[K(const T&, const MatrixBase<Matrix<float, 2, 1> >::StorageBaseType&) [35m[K[with T = Isometry2f][m[K[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K   required from here
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:29:[m[K [01;31m[Kerror: [m[Kno type named â€˜[01m[Ktype[m[Kâ€™ in â€˜[01m[Kstruct Eigen::internal::promote_scalar_arg<float, Isometry2f, false>[m[Kâ€™
   50 | EIGEN_MAKE_SCALAR_BINARY_OP([01;31m[Koperator[m[K*,product)
      |                             [01;31m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/util/Macros.h:1383:4:[m[K [01;36m[Knote: [m[Kin definition of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP_ONTHELEFT[m[Kâ€™
 1383 |   ([01;36m[KMETHOD[m[K)(const T& scalar, const StorageBaseType& matrix) { \
      |    [01;36m[K^~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h:50:1:[m[K [01;36m[Knote: [m[Kin expansion of macro â€˜[01m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[Kâ€™
   50 | [01;36m[KEIGEN_MAKE_SCALAR_BINARY_OP[m[K(operator*,product)
      | [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:326[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:515:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class MatrixDerived, class PermutationDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const MatrixBase<Derived>&, const PermutationBase<PermutationDerived>&)[m[Kâ€™
  515 | [01;36m[Koperator[m[K*(const MatrixBase<MatrixDerived> &matrix,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:515:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:527:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class PermutationDerived, class MatrixDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const PermutationBase<PermutationDerived>&, const MatrixBase<U>&)[m[Kâ€™
  527 | [01;36m[Koperator[m[K*(const PermutationBase<PermutationDerived> &permutation,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/PermutationMatrix.h:527:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::PermutationBase<PermutationDerived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
In file included from [01m[K/usr/include/eigen3/Eigen/Core:327[m[K:
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:313:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class MatrixDerived, class TranspositionsDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const MatrixBase<Derived>&, const TranspositionsBase<TranspositionsDerived>&)[m[Kâ€™
  313 | [01;36m[Koperator[m[K*(const MatrixBase<MatrixDerived> &matrix,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:313:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::MatrixBase<Derived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:325:1:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class TranspositionsDerived, class MatrixDerived> const Eigen::Product<MatrixDerived, PermutationDerived, 2> Eigen::[01;32m[Koperator*[m[K(const TranspositionsBase<TranspositionsDerived>&, const MatrixBase<U>&)[m[Kâ€™
  325 | [01;36m[Koperator[m[K*(const TranspositionsBase<TranspositionsDerived> &transpositions,
      | [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/eigen3/Eigen/src/Core/Transpositions.h:325:1:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/john/Desktop/rp_ros2_rviz/include/rp_ros2_rviz/grid_map.h:41:19:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst Isometry2f[m[Kâ€™ is not derived from â€˜[01m[Kconst Eigen::TranspositionsBase<TranspositionsDerived>[m[Kâ€™
   41 |     return (_ipiw*[01;36m[Kw[m[K)*inv_resolution+grid_origin;
      |                   [01;36m[K^[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/src/world_node.cpp:[m[K In constructor â€˜[01m[KWorldNode::[01;32m[KWorldNode[m[K()[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/src/world_node.cpp:53:17:[m[K [01;35m[Kwarning: [m[Kunused variable â€˜[01m[Kkey[m[Kâ€™ [[01;35m[K]8;;https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wunused-variable-Wunused-variable]8;;[m[K]
   53 |             int [01;35m[Kkey[m[K=0;
      |                 [01;35m[K^~~[m[K
[01m[K/home/john/Desktop/rp_ros2_rviz/src/world_node.cpp:[m[K In static member function â€˜[01m[Kstatic void WorldNode::[01;32m[KonMouse[m[K(int, int, int, int, void*)[m[Kâ€™:
[01m[K/home/john/Desktop/rp_ros2_rviz/src/world_node.cpp:79:54:[m[K [01;35m[Kwarning: [m[Kunused parameter â€˜[01m[Kval[m[Kâ€™ [[01;35m[K]8;;https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wunused-parameter-Wunused-parameter]8;;[m[K]
   79 |     static void onMouse(int event, int x, int y, [01;35m[Kint val[m[K, void* arg) {
      |                                                  [01;35m[K~~~~^~~[m[K
gmake[2]: *** [CMakeFiles/world_node.dir/build.make:76: CMakeFiles/world_node.dir/src/world_node.cpp.o] Error 1
gmake[1]: *** [CMakeFiles/Makefile2:165: CMakeFiles/world_node.dir/all] Error 2
gmake: *** [Makefile:146: all] Error 2
